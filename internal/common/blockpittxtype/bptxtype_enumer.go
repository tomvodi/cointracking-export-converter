// Code generated by "enumer -json -yaml -transform=snake -type=BpTxType"; DO NOT EDIT.

package blockpittxtype

import (
	"encoding/json"
	"fmt"
	"strings"
)

const _BpTxTypeName = "no_bp_tx_typedeposittradewithdrawalminingstakinggift_sentairdropgift_receivedmasternodeinterestpaymentderivative_profitderivative_feederivative_losshard_forkbountynon_taxable_innon_taxable_outlostcashbackfeeincome"

var _BpTxTypeIndex = [...]uint8{0, 13, 20, 25, 35, 41, 48, 57, 64, 77, 87, 95, 102, 119, 133, 148, 157, 163, 177, 192, 196, 204, 207, 213}

const _BpTxTypeLowerName = "no_bp_tx_typedeposittradewithdrawalminingstakinggift_sentairdropgift_receivedmasternodeinterestpaymentderivative_profitderivative_feederivative_losshard_forkbountynon_taxable_innon_taxable_outlostcashbackfeeincome"

func (i BpTxType) String() string {
	if i >= BpTxType(len(_BpTxTypeIndex)-1) {
		return fmt.Sprintf("BpTxType(%d)", i)
	}
	return _BpTxTypeName[_BpTxTypeIndex[i]:_BpTxTypeIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _BpTxTypeNoOp() {
	var x [1]struct{}
	_ = x[NoBpTxType-(0)]
	_ = x[Deposit-(1)]
	_ = x[Trade-(2)]
	_ = x[Withdrawal-(3)]
	_ = x[Mining-(4)]
	_ = x[Staking-(5)]
	_ = x[GiftSent-(6)]
	_ = x[Airdrop-(7)]
	_ = x[GiftReceived-(8)]
	_ = x[Masternode-(9)]
	_ = x[Interest-(10)]
	_ = x[Payment-(11)]
	_ = x[DerivativeProfit-(12)]
	_ = x[DerivativeFee-(13)]
	_ = x[DerivativeLoss-(14)]
	_ = x[HardFork-(15)]
	_ = x[Bounty-(16)]
	_ = x[NonTaxableIn-(17)]
	_ = x[NonTaxableOut-(18)]
	_ = x[Lost-(19)]
	_ = x[Cashback-(20)]
	_ = x[Fee-(21)]
	_ = x[Income-(22)]
}

var _BpTxTypeValues = []BpTxType{NoBpTxType, Deposit, Trade, Withdrawal, Mining, Staking, GiftSent, Airdrop, GiftReceived, Masternode, Interest, Payment, DerivativeProfit, DerivativeFee, DerivativeLoss, HardFork, Bounty, NonTaxableIn, NonTaxableOut, Lost, Cashback, Fee, Income}

var _BpTxTypeNameToValueMap = map[string]BpTxType{
	_BpTxTypeName[0:13]:         NoBpTxType,
	_BpTxTypeLowerName[0:13]:    NoBpTxType,
	_BpTxTypeName[13:20]:        Deposit,
	_BpTxTypeLowerName[13:20]:   Deposit,
	_BpTxTypeName[20:25]:        Trade,
	_BpTxTypeLowerName[20:25]:   Trade,
	_BpTxTypeName[25:35]:        Withdrawal,
	_BpTxTypeLowerName[25:35]:   Withdrawal,
	_BpTxTypeName[35:41]:        Mining,
	_BpTxTypeLowerName[35:41]:   Mining,
	_BpTxTypeName[41:48]:        Staking,
	_BpTxTypeLowerName[41:48]:   Staking,
	_BpTxTypeName[48:57]:        GiftSent,
	_BpTxTypeLowerName[48:57]:   GiftSent,
	_BpTxTypeName[57:64]:        Airdrop,
	_BpTxTypeLowerName[57:64]:   Airdrop,
	_BpTxTypeName[64:77]:        GiftReceived,
	_BpTxTypeLowerName[64:77]:   GiftReceived,
	_BpTxTypeName[77:87]:        Masternode,
	_BpTxTypeLowerName[77:87]:   Masternode,
	_BpTxTypeName[87:95]:        Interest,
	_BpTxTypeLowerName[87:95]:   Interest,
	_BpTxTypeName[95:102]:       Payment,
	_BpTxTypeLowerName[95:102]:  Payment,
	_BpTxTypeName[102:119]:      DerivativeProfit,
	_BpTxTypeLowerName[102:119]: DerivativeProfit,
	_BpTxTypeName[119:133]:      DerivativeFee,
	_BpTxTypeLowerName[119:133]: DerivativeFee,
	_BpTxTypeName[133:148]:      DerivativeLoss,
	_BpTxTypeLowerName[133:148]: DerivativeLoss,
	_BpTxTypeName[148:157]:      HardFork,
	_BpTxTypeLowerName[148:157]: HardFork,
	_BpTxTypeName[157:163]:      Bounty,
	_BpTxTypeLowerName[157:163]: Bounty,
	_BpTxTypeName[163:177]:      NonTaxableIn,
	_BpTxTypeLowerName[163:177]: NonTaxableIn,
	_BpTxTypeName[177:192]:      NonTaxableOut,
	_BpTxTypeLowerName[177:192]: NonTaxableOut,
	_BpTxTypeName[192:196]:      Lost,
	_BpTxTypeLowerName[192:196]: Lost,
	_BpTxTypeName[196:204]:      Cashback,
	_BpTxTypeLowerName[196:204]: Cashback,
	_BpTxTypeName[204:207]:      Fee,
	_BpTxTypeLowerName[204:207]: Fee,
	_BpTxTypeName[207:213]:      Income,
	_BpTxTypeLowerName[207:213]: Income,
}

var _BpTxTypeNames = []string{
	_BpTxTypeName[0:13],
	_BpTxTypeName[13:20],
	_BpTxTypeName[20:25],
	_BpTxTypeName[25:35],
	_BpTxTypeName[35:41],
	_BpTxTypeName[41:48],
	_BpTxTypeName[48:57],
	_BpTxTypeName[57:64],
	_BpTxTypeName[64:77],
	_BpTxTypeName[77:87],
	_BpTxTypeName[87:95],
	_BpTxTypeName[95:102],
	_BpTxTypeName[102:119],
	_BpTxTypeName[119:133],
	_BpTxTypeName[133:148],
	_BpTxTypeName[148:157],
	_BpTxTypeName[157:163],
	_BpTxTypeName[163:177],
	_BpTxTypeName[177:192],
	_BpTxTypeName[192:196],
	_BpTxTypeName[196:204],
	_BpTxTypeName[204:207],
	_BpTxTypeName[207:213],
}

// BpTxTypeString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func BpTxTypeString(s string) (BpTxType, error) {
	if val, ok := _BpTxTypeNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _BpTxTypeNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to BpTxType values", s)
}

// BpTxTypeValues returns all values of the enum
func BpTxTypeValues() []BpTxType {
	return _BpTxTypeValues
}

// BpTxTypeStrings returns a slice of all String values of the enum
func BpTxTypeStrings() []string {
	strs := make([]string, len(_BpTxTypeNames))
	copy(strs, _BpTxTypeNames)
	return strs
}

// IsABpTxType returns "true" if the value is listed in the enum definition. "false" otherwise
func (i BpTxType) IsABpTxType() bool {
	for _, v := range _BpTxTypeValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalJSON implements the json.Marshaler interface for BpTxType
func (i BpTxType) MarshalJSON() ([]byte, error) {
	return json.Marshal(i.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for BpTxType
func (i *BpTxType) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("BpTxType should be a string, got %s", data)
	}

	var err error
	*i, err = BpTxTypeString(s)
	return err
}

// MarshalYAML implements a YAML Marshaler for BpTxType
func (i BpTxType) MarshalYAML() (interface{}, error) {
	return i.String(), nil
}

// UnmarshalYAML implements a YAML Unmarshaler for BpTxType
func (i *BpTxType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var s string
	if err := unmarshal(&s); err != nil {
		return err
	}

	var err error
	*i, err = BpTxTypeString(s)
	return err
}
